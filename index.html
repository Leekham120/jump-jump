<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>拟物动态跳一跳 - 稳定版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #e0e5ec; font-family: -apple-system, sans-serif; touch-action: none; user-select: none; }
        
        /* 拟物风格 UI */
        #score-container {
            position: absolute; top: 40px; left: 40px; padding: 10px 25px; border-radius: 15px;
            background: #e0e5ec; box-shadow: 9px 9px 16px rgb(163,177,198,0.6), -9px -9px 16px rgba(255,255,255, 0.5);
            color: #444; font-size: 32px; font-weight: 900; z-index: 10;
        }

        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: #e0e5ec; padding: 40px; border-radius: 30px;
            box-shadow: 20px 20px 60px #bebebe, -20px -20px 60px #ffffff;
            text-align: center; display: none; z-index: 100;
        }

        button {
            background: #e0e5ec; color: #444; border: none; padding: 15px 40px; border-radius: 12px;
            cursor: pointer; margin-top: 20px; font-weight: bold;
            box-shadow: 6px 6px 12px #bebebe, -6px -6px 12px #ffffff;
            transition: all 0.2s;
        }
        button:active { box-shadow: inset 4px 4px 8px #bebebe, inset -4px -4px 8px #ffffff; }

        #power-bar-wrap {
            position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%);
            width: 150px; height: 8px; background: #d1d9e6; border-radius: 4px;
            box-shadow: inset 2px 2px 5px #b8b9be, inset -3px -3px 7px #ffffff;
            opacity: 0; transition: opacity 0.3s;
        }
        #power-bar-fill { width: 0%; height: 100%; background: #6d5dfc; }

        .score-pop {
            position: absolute; pointer-events: none; font-weight: 900; font-size: 28px;
            color: #6d5dfc; text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
            animation: scoreFloat 0.8s ease-out forwards; z-index: 20;
        }
        @keyframes scoreFloat {
            0% { transform: translateY(0) scale(0.5); opacity: 0; }
            30% { transform: translateY(-40px) scale(1.2); opacity: 1; }
            100% { transform: translateY(-80px) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>

    <div id="score-container">得分: <span id="score">0</span></div>
    <div id="power-bar-wrap"><div id="power-bar-fill"></div></div>
    
    <div id="game-over">
        <h2 style="color:#555">预判失误！</h2>
        <div style="font-size: 45px; color:#6d5dfc; font-weight:bold;" id="final-score">0</div>
        <button onclick="restartGame()">重新开始</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        const config = {
            gravity: 0.28,
            chargeSpeed: 0.14,
            maxPower: 14,
            minPower: 3.5,
            platformRadius: 6,
            playerHeight: 4,
            themeColor: 0xe0e5ec,
            ringInner: 0.8,  // 3分圆心
            ringMiddle: 2.5, // 2分中圈
        };

        let scene, camera, renderer, player, targetPlatform, currentPlatform;
        let platforms = [], movingPlatforms = [], power = 0, score = 0, isGameRunning = false;
        let state = { phase: 'ready', direction: 'x' };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(config.themeColor);
            scene.fog = new THREE.Fog(config.themeColor, 40, 130);

            const aspect = window.innerWidth / window.innerHeight;
            const d = 35;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(40, 45, 40);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(10, 50, 20);
            dirLight.castShadow = true;
            scene.add(dirLight);

            const handleStart = () => { if(state.phase === 'ready' && isGameRunning) { state.phase = 'charging'; power = 0; document.getElementById('power-bar-wrap').style.opacity = '1'; }};
            const handleEnd = () => { if(state.phase === 'charging' && isGameRunning) jump(); };

            window.addEventListener('mousedown', handleStart);
            window.addEventListener('mouseup', handleEnd);
            window.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(); }, {passive: false});
            window.addEventListener('touchend', handleEnd);
            window.addEventListener('resize', onWindowResize);

            startGame();
        }

        function createPlatform(x, z, isFirst = false) {
            const group = new THREE.Group();
            const isMoving = !isFirst && score >= 2 && Math.random() > 0.4;
            
            const material = new THREE.MeshStandardMaterial({ 
                color: isMoving ? 0xd1d9e6 : 0xffffff,
                roughness: 0.6, metalness: 0.1
            });
            const mesh = new THREE.Mesh(new THREE.CylinderGeometry(config.platformRadius, config.platformRadius, 4, 40), material);
            mesh.receiveShadow = true;
            group.add(mesh);

            // 靶心层
            const createRing = (radius, color, y) => {
                const r = new THREE.Mesh(new THREE.CircleGeometry(radius, 32), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.4 }));
                r.rotation.x = -Math.PI / 2; r.position.y = 2.01 + y; return r;
            };
            group.add(createRing(config.platformRadius, 0x000000, 0));
            group.add(createRing(config.ringMiddle, 0xffffff, 0.01));
            group.add(createRing(config.ringInner, 0x6d5dfc, 0.02));

            group.position.set(x, isFirst ? -2 : 30, z);
            scene.add(group);

            if(!isFirst) new TWEEN.Tween(group.position).to({ y: -2 }, 800).easing(TWEEN.Easing.Bounce.Out).start();

            if (isMoving) {
                const moveAxis = state.direction === 'x' ? 'z' : 'x';
                movingPlatforms.push({ 
                    mesh: group, axis: moveAxis, origin: group.position[moveAxis], 
                    range: 5 + Math.random() * 5, speed: 0.05 + Math.random() * 0.05, time: 0 
                });
            }
            return group;
        }

        function createPlayer() {
            player = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0x333, roughness: 0.2, metalness: 0.2 });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.8, config.playerHeight, 32), mat);
            const head = new THREE.Mesh(new THREE.SphereGeometry(1.2, 32, 32), mat);
            head.position.y = 2.5; body.castShadow = head.castShadow = true;
            player.add(body, head);
            player.position.set(0, 2, 0);
            scene.add(player);
        }

        function jump() {
            state.phase = 'jumping';
            document.getElementById('power-bar-wrap').style.opacity = '0';
            const finalPower = Math.max(power, config.minPower);
            let vY = finalPower * 0.72, vF = finalPower * 0.38;
            new TWEEN.Tween(player.scale).to({ x:1, y:1, z:1 }, 200).easing(TWEEN.Easing.Elastic.Out).start();

            const jumpLoop = () => {
                if(state.phase !== 'jumping') return;
                player.position[state.direction] -= vF * 0.15;
                player.position.y += vY * 0.15; vY -= config.gravity;
                player.rotation[state.direction === 'x' ? 'z' : 'x'] += (state.direction === 'x' ? 0.15 : -0.15);
                if(player.position.y <= 2) {
                    player.position.y = 2; player.rotation.set(0,0,0); checkLanding();
                } else requestAnimationFrame(jumpLoop);
            };
            requestAnimationFrame(jumpLoop);
        }

        function checkLanding() {
            const dist = Math.sqrt(Math.pow(player.position.x - targetPlatform.position.x, 2) + Math.pow(player.position.z - targetPlatform.position.z, 2));
            if (dist < config.platformRadius + 0.5) {
                let p = (dist <= config.ringInner) ? 3 : (dist <= config.ringMiddle ? 2 : 1);
                score += p; document.getElementById('score').innerText = score;
                showScorePop(p);
                movingPlatforms = movingPlatforms.filter(item => item.mesh !== targetPlatform);
                currentPlatform = targetPlatform; state.phase = 'ready'; spawnNextPlatform();
                new TWEEN.Tween(player.scale).to({ y: 0.85, x: 1.1 }, 80).yoyo(true).repeat(1).start();
            } else {
                state.phase = 'failed';
                new TWEEN.Tween(player.position).to({ y: -20 }, 600).onComplete(() => {
                    isGameRunning = false; document.getElementById('final-score').innerText = score;
                    document.getElementById('game-over').style.display = 'block';
                }).start();
            }
        }

        function showScorePop(points) {
            const pop = document.createElement('div');
            pop.className = 'score-pop';
            pop.innerText = `+${points}`;
            const vector = player.position.clone().project(camera);
            pop.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            pop.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.body.appendChild(pop);
            setTimeout(() => pop.remove(), 800);
        }

        function spawnNextPlatform() {
            state.direction = Math.random() > 0.5 ? 'x' : 'z';
            const distance = 18 + Math.random() * 10;
            const nextPos = {
                x: currentPlatform.position.x - (state.direction === 'x' ? distance : 0),
                z: currentPlatform.position.z - (state.direction === 'z' ? distance : 0)
            };
            targetPlatform = createPlatform(nextPos.x, nextPos.z);
            platforms.push(targetPlatform);
            if(platforms.length > 4) scene.remove(platforms.shift());
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            movingPlatforms.forEach(p => {
                p.time += p.speed;
                p.mesh.position[p.axis] = p.origin + Math.sin(p.time) * p.range;
            });
            if(isGameRunning && state.phase === 'charging') {
                if(power < config.maxPower) {
                    power += config.chargeSpeed;
                    document.getElementById('power-bar-fill').style.width = (power / config.maxPower) * 100 + '%';
                    player.scale.y -= 0.006; player.position.y -= 0.012;
                }
            }
            camera.position.x += (player.position.x + 40 - camera.position.x) * 0.05;
            camera.position.z += (player.position.z + 40 - camera.position.z) * 0.05;
            renderer.render(scene, camera);
        }

        function startGame() {
            score = 0; document.getElementById('score').innerText = '0';
            isGameRunning = true; state.phase = 'ready'; movingPlatforms = [];
            document.getElementById('game-over').style.display = 'none';
            if(player) scene.remove(player);
            platforms.forEach(p => scene.remove(p));
            platforms = [];
            currentPlatform = createPlatform(0, 0, true);
            platforms.push(currentPlatform);
            createPlayer();
            spawnNextPlatform();
        }

        function restartGame() { camera.position.set(40, 45, 40); startGame(); }
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 35; camera.left = -d * aspect; camera.right = d * aspect;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>