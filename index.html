<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>跳一跳 - 极简精致版</title>
    <style>
        body { margin: 0; overflow: hidden; background: linear-gradient(to bottom, #cfd9df 0%, #e2ebf0 100%); font-family: -apple-system, sans-serif; touch-action: none; user-select: none; }
        
        /* 顶部计分板 */
        #score-container {
            position: absolute; top: 40px; left: 40px; padding: 12px 28px; border-radius: 20px;
            background: rgba(255, 255, 255, 0.6); backdrop-filter: blur(15px);
            box-shadow: 0 8px 32px rgba(0,0,0,0.05); border: 1px solid rgba(255,255,255,0.3);
            color: #444; font-size: 30px; font-weight: 900; z-index: 10;
        }

        /* 游戏结束弹窗 */
        #game-over {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9); backdrop-filter: blur(20px);
            padding: 40px; border-radius: 35px; text-align: center; display: none; z-index: 1000;
            box-shadow: 0 30px 100px rgba(0,0,0,0.1); width: 280px;
        }

        button {
            background: #6d5dfc; color: white; border: none; padding: 18px 0; width: 100%;
            font-size: 20px; border-radius: 18px; cursor: pointer; margin-top: 25px; font-weight: bold;
            box-shadow: 0 10px 20px rgba(109, 93, 252, 0.3); transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        button:active { transform: scale(0.96); opacity: 0.9; }

        /* 蓄力条 */
        #power-bar-wrap {
            position: absolute; bottom: 12%; left: 50%; transform: translateX(-50%);
            width: 180px; height: 10px; background: rgba(0,0,0,0.05); border-radius: 20px;
            overflow: hidden; opacity: 0; transition: opacity 0.3s; z-index: 5;
        }
        #power-bar-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #6d5dfc, #a399ff); }

        /* 得分弹出动画 */
        .score-pop {
            position: absolute; pointer-events: none; font-weight: 900; font-size: 36px;
            color: #6d5dfc; animation: scoreFloat 0.8s ease-out forwards; z-index: 20;
        }
        @keyframes scoreFloat {
            0% { transform: translateY(0) scale(0.4); opacity: 0; }
            40% { transform: translateY(-50px) scale(1.1); opacity: 1; }
            100% { transform: translateY(-90px) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>

    <div id="score-container">
        <span style="font-size: 14px; opacity: 0.5; display: block; letter-spacing: 1px;">SCORE</span>
        <span id="score">0</span>
    </div>
    
    <div id="power-bar-wrap"><div id="power-bar-fill"></div></div>
    
    <div id="game-over">
        <h3 style="color:#aaa; margin:0; letter-spacing: 2px; font-size: 14px;">GAME OVER</h3>
        <div style="font-size: 60px; color:#444; font-weight:900; margin: 10px 0;" id="final-score">0</div>
        <button id="retry-btn">RESTART</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

    <script>
        // 核心配置：已降低移动圆盘难度
        const config = {
            gravity: 0.28,
            chargeSpeed: 0.14,
            maxPower: 14,
            minPower: 3.5,
            platformRadius: 6,
            playerHeight: 4,
            landingTolerance: 0.8, // 判定容差，增加成功率
            frustumSize: 42,      // 视口大小
            palette: [0x91a8d0, 0xf7cac9, 0x92a8d1, 0xdec2cb, 0xb5a191, 0x94b4a4, 0xe7eff6, 0xd6cbd3]
        };

        let scene, camera, renderer, player, targetPlatform, currentPlatform;
        let platforms = [], movingPlatforms = [], particles = [], power = 0, score = 0, isGameRunning = false;
        let state = { phase: 'ready', direction: 'x' };

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0xcfd9df, 60, 160);

            camera = new THREE.OrthographicCamera(0, 0, 0, 0, 1, 1000);
            updateCameraProjection();
            camera.position.set(45, 45, 45); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.5);
            mainLight.position.set(20, 50, 20);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 1024;
            mainLight.shadow.mapSize.height = 1024;
            scene.add(mainLight);

            setupControls();
            startGame();
        }

        function updateCameraProjection() {
            const aspect = window.innerWidth / window.innerHeight;
            const h = config.frustumSize;
            const w = config.frustumSize * aspect;
            camera.left = -w; camera.right = w; camera.top = h; camera.bottom = -h;
            camera.updateProjectionMatrix();
        }

        function setupControls() {
            const handleStart = (e) => {
                if(state.phase === 'ready' && isGameRunning) {
                    state.phase = 'charging'; power = 0;
                    document.getElementById('power-bar-wrap').style.opacity = '1';
                }
            };
            const handleEnd = (e) => { if(state.phase === 'charging' && isGameRunning) jump(); };

            // PC端监听
            window.addEventListener('mousedown', handleStart);
            window.addEventListener('mouseup', handleEnd);
            
            // 移动端监听
            window.addEventListener('touchstart', (e) => {
                if (e.target.tagName !== 'BUTTON') { e.preventDefault(); handleStart(); }
            }, {passive: false});
            window.addEventListener('touchend', (e) => {
                if (state.phase === 'charging') handleEnd();
            });

            // 重新开始按钮优化
            const retryBtn = document.getElementById('retry-btn');
            const restartAction = (e) => { e.stopPropagation(); e.preventDefault(); restartGame(); };
            retryBtn.addEventListener('click', restartAction);
            retryBtn.addEventListener('touchend', restartAction);

            window.addEventListener('resize', () => {
                updateCameraProjection();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function createPlatform(x, z, isFirst = false) {
            const group = new THREE.Group();
            // 降低难度：仅30%概率出现移动圆盘
            const isMoving = !isFirst && score >= 2 && Math.random() > 0.7;
            const randomColor = config.palette[Math.floor(Math.random() * config.palette.length)];
            
            const material = new THREE.MeshPhysicalMaterial({ 
                color: isFirst ? 0xffffff : randomColor, roughness: 0.6, metalness: 0.1, clearcoat: 0.1
            });
            const mesh = new THREE.Mesh(new THREE.CylinderGeometry(config.platformRadius, config.platformRadius, 4, 40), material);
            mesh.receiveShadow = mesh.castShadow = true;
            group.userData.color = randomColor;
            group.add(mesh);

            // 绘制装饰环（靶心）
            const createRing = (radius, color, y, op = 0.5) => {
                const r = new THREE.Mesh(new THREE.CircleGeometry(radius, 32), new THREE.MeshBasicMaterial({ color, transparent: true, opacity: op }));
                r.rotation.x = -Math.PI / 2; r.position.y = 2.02 + y; return r;
            };
            group.add(createRing(config.platformRadius, 0x000000, 0, 0.05));
            group.add(createRing(2.5, 0xffffff, 0.01, 0.7));
            group.add(createRing(0.8, 0x6d5dfc, 0.02, 0.8));

            group.position.set(x, isFirst ? -2 : 30, z);
            scene.add(group);
            
            if(!isFirst) new TWEEN.Tween(group.position).to({ y: -2 }, 1000).easing(TWEEN.Easing.Elastic.Out).start();

            if (isMoving) {
                const moveAxis = state.direction === 'x' ? 'z' : 'x';
                movingPlatforms.push({ 
                    mesh: group, axis: moveAxis, origin: moveAxis === 'x' ? x : z, 
                    range: 2.5 + Math.random() * 1.5, // 缩小摆动范围
                    speed: 0.02 + Math.random() * 0.02, // 减慢摆动速度
                    time: Math.random() * 10 
                });
            }
            return group;
        }

        function createPlayer() {
            player = new THREE.Group();
            const mat = new THREE.MeshPhysicalMaterial({ color: 0x444444, roughness: 0.2, metalness: 0.2 });
            const body = new THREE.Mesh(new THREE.CylinderGeometry(1, 1.8, config.playerHeight, 32), mat);
            const head = new THREE.Mesh(new THREE.SphereGeometry(1.2, 32, 32), mat);
            head.position.y = 2.5; body.castShadow = head.castShadow = true;
            player.add(body, head);
            player.position.set(0, 2, 0);
            scene.add(player);
        }

        function createExplosion(pos, color) {
            for(let i=0; i<15; i++) {
                const p = new THREE.Mesh(new THREE.SphereGeometry(0.35, 8, 8), new THREE.MeshBasicMaterial({ color }));
                p.position.copy(pos);
                const vel = new THREE.Vector3((Math.random()-0.5)*0.9, Math.random()*0.9, (Math.random()-0.5)*0.9);
                scene.add(p);
                particles.push({ mesh: p, vel, life: 1.0 });
            }
        }

        function jump() {
            state.phase = 'jumping';
            document.getElementById('power-bar-wrap').style.opacity = '0';
            const finalPower = Math.max(power, config.minPower);
            let vY = finalPower * 0.72, vF = finalPower * 0.38;
            new TWEEN.Tween(player.scale).to({ x:1, y:1, z:1 }, 200).easing(TWEEN.Easing.Back.Out).start();

            const jumpLoop = () => {
                if(state.phase !== 'jumping') return;
                player.position[state.direction] -= vF * 0.15;
                player.position.y += vY * 0.15; vY -= config.gravity;
                player.rotation[state.direction === 'x' ? 'z' : 'x'] += (state.direction === 'x' ? 0.15 : -0.15);
                if(player.position.y <= 2) {
                    player.position.y = 2; player.rotation.set(0,0,0); checkLanding();
                } else requestAnimationFrame(jumpLoop);
            };
            requestAnimationFrame(jumpLoop);
        }

        function checkLanding() {
            const dist = Math.sqrt(Math.pow(player.position.x - targetPlatform.position.x, 2) + Math.pow(player.position.z - targetPlatform.position.z, 2));
            // 使用容差判定
            if (dist < config.platformRadius + config.landingTolerance) {
                let p = 1;
                if (dist <= 0.8) { p = 3; createExplosion(player.position, targetPlatform.userData.color); }
                else if (dist <= 2.5) p = 2;
                
                score += p; document.getElementById('score').innerText = score;
                showScorePop(p);
                movingPlatforms = movingPlatforms.filter(item => item.mesh !== targetPlatform);
                currentPlatform = targetPlatform; state.phase = 'ready'; spawnNextPlatform();
                new TWEEN.Tween(player.scale).to({ y: 0.8, x: 1.2, z: 1.2 }, 80).yoyo(true).repeat(1).start();
            } else {
                state.phase = 'failed';
                new TWEEN.Tween(player.position).to({ y: -20 }, 600).easing(TWEEN.Easing.Quadratic.In).onComplete(() => {
                    isGameRunning = false; document.getElementById('final-score').innerText = score;
                    document.getElementById('game-over').style.display = 'block';
                }).start();
            }
        }

        function showScorePop(points) {
            const pop = document.createElement('div');
            pop.className = 'score-pop'; pop.innerText = `+${points}`;
            const vector = player.position.clone().project(camera);
            pop.style.left = `${(vector.x * 0.5 + 0.5) * window.innerWidth}px`;
            pop.style.top = `${(-(vector.y * 0.5) + 0.5) * window.innerHeight}px`;
            document.body.appendChild(pop);
            setTimeout(() => pop.remove(), 800);
        }

        function spawnNextPlatform() {
            state.direction = Math.random() > 0.5 ? 'x' : 'z';
            const distance = 20 + Math.random() * 8; 
            const nextPos = {
                x: currentPlatform.position.x - (state.direction === 'x' ? distance : 0),
                z: currentPlatform.position.z - (state.direction === 'z' ? distance : 0)
            };
            targetPlatform = createPlatform(nextPos.x, nextPos.z);
            platforms.push(targetPlatform);
            if(platforms.length > 4) scene.remove(platforms.shift());
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);

            // 粒子更新
            for(let i = particles.length-1; i>=0; i--) {
                const p = particles[i];
                p.mesh.position.add(p.vel); p.life -= 0.025; p.mesh.scale.setScalar(p.life);
                if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }

            // 平台平缓摆动
            movingPlatforms.forEach(p => {
                p.time += p.speed;
                p.mesh.position[p.axis] = p.origin + Math.sin(p.time) * p.range;
            });

            // 目标圆盘微弱呼吸动效
            if(targetPlatform && state.phase === 'ready') {
                targetPlatform.position.y = -2 + Math.sin(time * 0.002) * 0.15;
            }

            // 蓄力逻辑
            if(isGameRunning && state.phase === 'charging') {
                if(power < config.maxPower) {
                    power += config.chargeSpeed;
                    document.getElementById('power-bar-fill').style.width = (power / config.maxPower) * 100 + '%';
                    player.scale.y -= 0.007; player.position.y -= 0.014;
                }
            }

            // 视角优化：中点平滑跟随
            const lookTarget = new THREE.Vector3().addVectors(player.position, targetPlatform.position).multiplyScalar(0.5);
            camera.position.x += (lookTarget.x + 45 - camera.position.x) * 0.06;
            camera.position.z += (lookTarget.z + 45 - camera.position.z) * 0.06;
            
            renderer.render(scene, camera);
        }

        function startGame() {
            score = 0; document.getElementById('score').innerText = '0';
            isGameRunning = true; state.phase = 'ready'; movingPlatforms = []; particles = [];
            document.getElementById('game-over').style.display = 'none';
            if(player) scene.remove(player);
            platforms.forEach(p => scene.remove(p));
            platforms = [];
            currentPlatform = createPlatform(0, 0, true);
            platforms.push(currentPlatform);
            createPlayer();
            spawnNextPlatform();
        }

        function restartGame() {
            camera.position.set(45, 45, 45);
            startGame();
        }
    </script>
</body>
</html>